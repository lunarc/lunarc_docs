{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to the Lunarc Documentation pages\n\n\nHere you will find all of the documentation for the Lunarc resources in a easy to find place.", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-the-lunarc-documentation-pages", 
            "text": "Here you will find all of the documentation for the Lunarc resources in a easy to find place.", 
            "title": "Welcome to the Lunarc Documentation pages"
        }, 
        {
            "location": "/aurora_modules/", 
            "text": "Using supported software on Lunarc's Aurora service\n\n\nAuthor: Joachim Hein (Lunarc)\n\n\nHierachical module naming scheme\n\n\nWith the start of the Aurora service Lunarc is using an hierachical module naming scheme.  Hierachical modules ensure that the correct shared libraries are available when running an application, while keeping screen output of standard module commands such as \nmodule avail\n managable.\n\n\nHierachical naming scheme concept\n\n\nWhen loging into the system, you only get access to those modules that do not require any special dynamic libraries.  After \nloading a compiler module\n you obtaing access to those packages that have been build with that specific compiler and depend on its shared libraries.  For many compilers this will include one or more matching MPI libraries.  After loading an MPI library additional software packages, depending on this pair (compiler \n MPI library), will become available.  Users should take note that in many cases loading an MPI library is required for software that doesn't really depend on it.\n\n\nUsing Modules\n\n\nThe module system on Aurora is utilising the Lua based \nLmod\n software.\n\n\nLoading packages\n\n\nThe command\n\n\nmodule avail\n\n\n\n\nshows the modules that can currently be accessed.  The output will look similar to\n\n\n--------------------------------- /sw/Modules/modulefiles/Core ---------------------------------\n   matlab/8.5\n\n-------------------------------- /sw/easybuild/modules/all/Core --------------------------------\n   Bison/3.0.4                    gompi/2015b\n   EasyBuild/2.5.0                gompi/2016a                        (D)\n   EasyBuild/2.6.0         (D)    icc/2015.3.187-GNU-4.9.3-2.25\n   GCC/4.9.3-binutils-2.25        icc/2016.1.150-GCC-4.9.3-2.25      (D)\n   GCC/4.9.3-2.25                 iccifort/2015.3.187-GNU-4.9.3-2.25\n   GCC/5.3.0               (D)    iccifort/2016.1.150-GCC-4.9.3-2.25 (D)\n   GCCcore/4.9.3                  ifort/2015.3.187-GNU-4.9.3-2.25\n   GNU/4.9.3-2.25                 ifort/2016.1.150-GCC-4.9.3-2.25    (D)\n   Java/1.8.0_72                  iimpi/7.3.5-GNU-4.9.3-2.25\n   M4/1.4.17                      iimpi/2016.01-GCC-4.9.3-2.25       (D)\n   binutils/2.25                  intel/2015b\n   flex/2.5.39                    intel/2016a\n   foss/2015b                     intel/2016.01                      (D)\n   foss/2016a              (D)    zlib/1.2.8\n\n-------------------------------- /sw/lmod/lmod/modulefiles/Core --------------------------------\n   lmod/6.0.24    settarg/6.0.24\n\n\n\n\nIn this example you can see modules and versions located in 3 directories.  Any of these modules can be accessed directly.  To obtain access to the software inside e.g. the toolchain module \nfoss/2016a\n one loads the module by issueing\n\n\nmodule load foss/2016a\n\n\n\n\nMany modules will load a number of modules, which they depend on.\nSince in the above output from \nmodule avail\n version 2016a is marked\nas the default version, the command\n\n\nmodule load foss\n\n\n\n\nwould have the same effect unless the default changes, which it may\ndo, if\n\n\n\n\nYou load a module\n\n\nThe lunarc team installs another version of the software\n\n\n\n\nSo if you require a specific version, the Lunarc team strongly\nrecommends to not rely on defaults, but explicitly specify the version\nyou are after.\n\n\nTo see what modules you have currently loaded use\n\n\nmodule list\n\n\n\n\nIn a hierachical module naming scheme the command \nmodule avail\n is\nnot as useful as it is in a flat module naming scheme which Lunarc\ndeployed on earlier services.   In many situations \nmodule avail\n\nresulted in the desired action, one has to use the \nmodule spider\n\ncommand which is descripted in the text below.\n\n\nPurging the loaded modules\n\n\nMany modules will load a number extra of modules, which they depend on.\nWhen unloading a  module, these dependencies will typically not be unloaded.  For\nthat reason we currently recommend using\n\n\nmodule purge\n\n\n\n\nwhen loaded modules are no longer needed.   You would then start\nloading the modules required for the next task you need to accomplish\nfrom scratch.\n\n\nSeaching for all software packages\n\n\nIn practical use, the command \nmodule spider\n is key to search for packages in an Lmod based hierachical module naming scheme.  To get an overview on the software installed on Aurora, simply type\n\n\nmodule spider\n\n\n\n\nat the command prompt.  This will create an output similar to:\n\n\n---------------------------------------------------------------------\nThe following is a list of the modules currently available:\n---------------------------------------------------------------------\n  Autoconf: Autoconf/2.69\n\n  Automake: Automake/1.15\n\n  Autotools: Autotools/20150215\n\n  Bison: Bison/3.0.4\n\n  Boost: Boost/1.58.0-Python-2.7.9\n\n  CMake: CMake/3.2.2, CMake/3.3.2\n\n  Cube: Cube/4.3\n\n  EasyBuild: EasyBuild/2.5.0, EasyBuild/2.6.0\n\n  FFTW: FFTW/3.3.4\n\n  GCC: GCC/4.9.3-binutils-2.25, GCC/4.9.3-2.25, GCC/5.3.0\n\n  GCCcore: GCCcore/4.9.3\n\n  GLib: GLib/2.42.1, GLib/2.46.0\n\n  GNU: GNU/4.9.3-2.25\n\n  GROMACS: GROMACS/5.0.4-mt, GROMACS/5.0.5-hybrid\n\n  ...\n\n\n\n\nThis is a full list of the packages and versions available on the service.  \n\n\nSearching for a specific package\n\n\nIf you are looking for a specific package and have an idea on what its name might be, you can give this as an argument to \nmodule spider\n.   This argument is case insensitive.  \n\n\nExample: Accessing a Gromacs version\n\n\nFor example, when looking to run Gromacs:\n\n\nmodule spider gromacs\n\n\n\n\nYou obtain output simlar to:\n\n\n---------------------------------------------------------------------------------\n  GROMACS:\n---------------------------------------------------------------------------------\n     Versions:\n        GROMACS/5.0.4-mt\n        GROMACS/5.0.5-hybrid\n\n---------------------------------------------------------------------------------\n  To find detailed information about GROMACS please enter the full name.\n  For example:\n\n     $ module spider GROMACS/5.0.5-hybrid\n---------------------------------------------------------------------------------\n\n\n\n\nThis tells you that the multi threaded version 5.0.4 and the hybrid version 5.0.5 are installed.  If you want to use the version 5.0.5 issue the command:\n\n\nmodule spider GROMACS/5.0.5-hybrid\n\n\n\n\nYou get the folling output\n\n\n---------------------------------------------------------------------------------\n  GROMACS: GROMACS/5.0.5-hybrid\n---------------------------------------------------------------------------------\n\n    This module can only be loaded through the following modules:\n\n      icc/2016.1.150-GCC-4.9.3-2.25  impi/5.1.2.150\n      ifort/2016.1.150-GCC-4.9.3-2.25  impi/5.1.2.150\n\n... \n\n\n\n\nThis lists the modules you have to load before accessing Gromacs.  In this case you have two options, we choose the first option.  We load\n\n\nmodule load icc/2016.1.150-GCC-4.9.3-2.25\nmodule load impi/5.1.2.150\n\n\n\n\nAfter which we can load the gromacs installation:\n\n\nmodule load GROMACS/5.0.5-hybrid\n\n\n\n\nLoading this module will load a number of additional module require for Gromacs to work.\n\n\nExample accessing R\n\n\nThis is another example on how to access a specific software package.  This time we want to run the statistical software package R.\n\n\nmodule spider R\n\n\n\n\nOne gets:\n\n\n------------------------------------------------------------------\n  R:\n------------------------------------------------------------------\n     Versions:\n        R/3.2.1-bare\n        R/3.2.1\n        R/3.2.3\n\n     Other possible modules matches:\n        GCCcore  GROMACS  SuiteSparse  cURL  fixesproto  fontsproto  ...\n\n------------------------------------------------------------------\n  To find other possible module matches do:\n      module -r spider '.*R.*'\n\n------------------------------------------------------------------\n  To find detailed information about R please enter the full name.\n  For example:\n\n     $ module spider R/3.2.1-bare\n------------------------------------------------------------------\n\n\n\n\nIf we are interested in version 3.2.3, we do a\n\n\nmodule spider R/3.2.3\n\n\n\n\nnext and get the following info:\n\n\n------------------------------------------------------------------\n  R: R/3.2.3\n------------------------------------------------------------------\n\n     Other possible modules matches:\n        GCCcore, GROMACS, SuiteSparse, cURL, fixesproto, ...\n\n    This module can only be loaded through the following modules:\n\n      GCC/4.9.3-binutils-2.25  OpenMPI/1.8.8\n\n...\n\n\n\n\nThe output states the two modules that need loading to get access to this R version.  We issue\n\n\nmodule load GCC/4.9.3-binutils-2.25\nmodule load OpenMPI/1.8.8\nmodule load R/3.2.3\n\n\n\n\nand have acces to R.\n\n\nLmod cache\n\n\nTo improve the performance of the \nmodule spider\n command, lmod caches\nthe entire module structure of the system.  This cache is currently\nconfigured to be updated once in 24 hours.\n\n\nThis can have the effect that you see an outdated version of the\nmodule tree, when using commands such as \nmodule avail\nor \nmodule\nspider\n.   The cache file is stored in the directory\n\n$HOME/.lmod.d/.cache/\n remove the cache file and lmod will recreate\nit for you.\n\n\nToolchains\n\n\nA signficant portion of the Aurora software is build \nEasyBuild\n software framework.  This frame work provides so called \nToolchains\n which are utilised to build software.  Lunarc recommends using these toolchains even when building software outside the EasyBuild framework.\n\n\nLunarc actively maintains the following toolchains\n+ \nfoss\n: BLACS, FFTW, GCC, OpenBLAS, OpenMPI, ScaLAPACK\n+ \ngompi\n: GCC, OpenMPI\n+ \nintel\n: icc, ifort, MKL, Intel MPI\n+ \niimpi\n: icc, ifort, Intel MPI\n\n\nIf you require additional toolchains, contact \nLunarc support\n to discuss your requirements.", 
            "title": "Aurora Modules"
        }, 
        {
            "location": "/aurora_modules/#using-supported-software-on-lunarcs-aurora-service", 
            "text": "Author: Joachim Hein (Lunarc)", 
            "title": "Using supported software on Lunarc's Aurora service"
        }, 
        {
            "location": "/aurora_modules/#hierachical-module-naming-scheme", 
            "text": "With the start of the Aurora service Lunarc is using an hierachical module naming scheme.  Hierachical modules ensure that the correct shared libraries are available when running an application, while keeping screen output of standard module commands such as  module avail  managable.", 
            "title": "Hierachical module naming scheme"
        }, 
        {
            "location": "/aurora_modules/#hierachical-naming-scheme-concept", 
            "text": "When loging into the system, you only get access to those modules that do not require any special dynamic libraries.  After  loading a compiler module  you obtaing access to those packages that have been build with that specific compiler and depend on its shared libraries.  For many compilers this will include one or more matching MPI libraries.  After loading an MPI library additional software packages, depending on this pair (compiler   MPI library), will become available.  Users should take note that in many cases loading an MPI library is required for software that doesn't really depend on it.", 
            "title": "Hierachical naming scheme concept"
        }, 
        {
            "location": "/aurora_modules/#using-modules", 
            "text": "The module system on Aurora is utilising the Lua based  Lmod  software.", 
            "title": "Using Modules"
        }, 
        {
            "location": "/aurora_modules/#loading-packages", 
            "text": "The command  module avail  shows the modules that can currently be accessed.  The output will look similar to  --------------------------------- /sw/Modules/modulefiles/Core ---------------------------------\n   matlab/8.5\n\n-------------------------------- /sw/easybuild/modules/all/Core --------------------------------\n   Bison/3.0.4                    gompi/2015b\n   EasyBuild/2.5.0                gompi/2016a                        (D)\n   EasyBuild/2.6.0         (D)    icc/2015.3.187-GNU-4.9.3-2.25\n   GCC/4.9.3-binutils-2.25        icc/2016.1.150-GCC-4.9.3-2.25      (D)\n   GCC/4.9.3-2.25                 iccifort/2015.3.187-GNU-4.9.3-2.25\n   GCC/5.3.0               (D)    iccifort/2016.1.150-GCC-4.9.3-2.25 (D)\n   GCCcore/4.9.3                  ifort/2015.3.187-GNU-4.9.3-2.25\n   GNU/4.9.3-2.25                 ifort/2016.1.150-GCC-4.9.3-2.25    (D)\n   Java/1.8.0_72                  iimpi/7.3.5-GNU-4.9.3-2.25\n   M4/1.4.17                      iimpi/2016.01-GCC-4.9.3-2.25       (D)\n   binutils/2.25                  intel/2015b\n   flex/2.5.39                    intel/2016a\n   foss/2015b                     intel/2016.01                      (D)\n   foss/2016a              (D)    zlib/1.2.8\n\n-------------------------------- /sw/lmod/lmod/modulefiles/Core --------------------------------\n   lmod/6.0.24    settarg/6.0.24  In this example you can see modules and versions located in 3 directories.  Any of these modules can be accessed directly.  To obtain access to the software inside e.g. the toolchain module  foss/2016a  one loads the module by issueing  module load foss/2016a  Many modules will load a number of modules, which they depend on.\nSince in the above output from  module avail  version 2016a is marked\nas the default version, the command  module load foss  would have the same effect unless the default changes, which it may\ndo, if   You load a module  The lunarc team installs another version of the software   So if you require a specific version, the Lunarc team strongly\nrecommends to not rely on defaults, but explicitly specify the version\nyou are after.  To see what modules you have currently loaded use  module list  In a hierachical module naming scheme the command  module avail  is\nnot as useful as it is in a flat module naming scheme which Lunarc\ndeployed on earlier services.   In many situations  module avail \nresulted in the desired action, one has to use the  module spider \ncommand which is descripted in the text below.", 
            "title": "Loading packages"
        }, 
        {
            "location": "/aurora_modules/#purging-the-loaded-modules", 
            "text": "Many modules will load a number extra of modules, which they depend on.\nWhen unloading a  module, these dependencies will typically not be unloaded.  For\nthat reason we currently recommend using  module purge  when loaded modules are no longer needed.   You would then start\nloading the modules required for the next task you need to accomplish\nfrom scratch.", 
            "title": "Purging the loaded modules"
        }, 
        {
            "location": "/aurora_modules/#seaching-for-all-software-packages", 
            "text": "In practical use, the command  module spider  is key to search for packages in an Lmod based hierachical module naming scheme.  To get an overview on the software installed on Aurora, simply type  module spider  at the command prompt.  This will create an output similar to:  ---------------------------------------------------------------------\nThe following is a list of the modules currently available:\n---------------------------------------------------------------------\n  Autoconf: Autoconf/2.69\n\n  Automake: Automake/1.15\n\n  Autotools: Autotools/20150215\n\n  Bison: Bison/3.0.4\n\n  Boost: Boost/1.58.0-Python-2.7.9\n\n  CMake: CMake/3.2.2, CMake/3.3.2\n\n  Cube: Cube/4.3\n\n  EasyBuild: EasyBuild/2.5.0, EasyBuild/2.6.0\n\n  FFTW: FFTW/3.3.4\n\n  GCC: GCC/4.9.3-binutils-2.25, GCC/4.9.3-2.25, GCC/5.3.0\n\n  GCCcore: GCCcore/4.9.3\n\n  GLib: GLib/2.42.1, GLib/2.46.0\n\n  GNU: GNU/4.9.3-2.25\n\n  GROMACS: GROMACS/5.0.4-mt, GROMACS/5.0.5-hybrid\n\n  ...  This is a full list of the packages and versions available on the service.", 
            "title": "Seaching for all software packages"
        }, 
        {
            "location": "/aurora_modules/#searching-for-a-specific-package", 
            "text": "If you are looking for a specific package and have an idea on what its name might be, you can give this as an argument to  module spider .   This argument is case insensitive.    Example: Accessing a Gromacs version  For example, when looking to run Gromacs:  module spider gromacs  You obtain output simlar to:  ---------------------------------------------------------------------------------\n  GROMACS:\n---------------------------------------------------------------------------------\n     Versions:\n        GROMACS/5.0.4-mt\n        GROMACS/5.0.5-hybrid\n\n---------------------------------------------------------------------------------\n  To find detailed information about GROMACS please enter the full name.\n  For example:\n\n     $ module spider GROMACS/5.0.5-hybrid\n---------------------------------------------------------------------------------  This tells you that the multi threaded version 5.0.4 and the hybrid version 5.0.5 are installed.  If you want to use the version 5.0.5 issue the command:  module spider GROMACS/5.0.5-hybrid  You get the folling output  ---------------------------------------------------------------------------------\n  GROMACS: GROMACS/5.0.5-hybrid\n---------------------------------------------------------------------------------\n\n    This module can only be loaded through the following modules:\n\n      icc/2016.1.150-GCC-4.9.3-2.25  impi/5.1.2.150\n      ifort/2016.1.150-GCC-4.9.3-2.25  impi/5.1.2.150\n\n...   This lists the modules you have to load before accessing Gromacs.  In this case you have two options, we choose the first option.  We load  module load icc/2016.1.150-GCC-4.9.3-2.25\nmodule load impi/5.1.2.150  After which we can load the gromacs installation:  module load GROMACS/5.0.5-hybrid  Loading this module will load a number of additional module require for Gromacs to work.  Example accessing R  This is another example on how to access a specific software package.  This time we want to run the statistical software package R.  module spider R  One gets:  ------------------------------------------------------------------\n  R:\n------------------------------------------------------------------\n     Versions:\n        R/3.2.1-bare\n        R/3.2.1\n        R/3.2.3\n\n     Other possible modules matches:\n        GCCcore  GROMACS  SuiteSparse  cURL  fixesproto  fontsproto  ...\n\n------------------------------------------------------------------\n  To find other possible module matches do:\n      module -r spider '.*R.*'\n\n------------------------------------------------------------------\n  To find detailed information about R please enter the full name.\n  For example:\n\n     $ module spider R/3.2.1-bare\n------------------------------------------------------------------  If we are interested in version 3.2.3, we do a  module spider R/3.2.3  next and get the following info:  ------------------------------------------------------------------\n  R: R/3.2.3\n------------------------------------------------------------------\n\n     Other possible modules matches:\n        GCCcore, GROMACS, SuiteSparse, cURL, fixesproto, ...\n\n    This module can only be loaded through the following modules:\n\n      GCC/4.9.3-binutils-2.25  OpenMPI/1.8.8\n\n...  The output states the two modules that need loading to get access to this R version.  We issue  module load GCC/4.9.3-binutils-2.25\nmodule load OpenMPI/1.8.8\nmodule load R/3.2.3  and have acces to R.", 
            "title": "Searching for a specific package"
        }, 
        {
            "location": "/aurora_modules/#lmod-cache", 
            "text": "To improve the performance of the  module spider  command, lmod caches\nthe entire module structure of the system.  This cache is currently\nconfigured to be updated once in 24 hours.  This can have the effect that you see an outdated version of the\nmodule tree, when using commands such as  module avail or  module\nspider .   The cache file is stored in the directory $HOME/.lmod.d/.cache/  remove the cache file and lmod will recreate\nit for you.", 
            "title": "Lmod cache"
        }, 
        {
            "location": "/aurora_modules/#toolchains", 
            "text": "A signficant portion of the Aurora software is build  EasyBuild  software framework.  This frame work provides so called  Toolchains  which are utilised to build software.  Lunarc recommends using these toolchains even when building software outside the EasyBuild framework.  Lunarc actively maintains the following toolchains\n+  foss : BLACS, FFTW, GCC, OpenBLAS, OpenMPI, ScaLAPACK\n+  gompi : GCC, OpenMPI\n+  intel : icc, ifort, MKL, Intel MPI\n+  iimpi : icc, ifort, Intel MPI  If you require additional toolchains, contact  Lunarc support  to discuss your requirements.", 
            "title": "Toolchains"
        }
    ]
}